<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES(Elasticsearch)解除索引只读限制</title>
    <url>/2023/09/21/ES-Elasticsearch-%E8%A7%A3%E9%99%A4%E7%B4%A2%E5%BC%95%E5%8F%AA%E8%AF%BB%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>服务器 空间满了，导致 ES 自动设置了只读限制</p>
<p>在此之前，先清空多余的日志</p>
<p>在elasticsearch 目录下 进入 logs 文件夹，清空后缀为 .gz和 gc.log.xx (xx为任意字符) 的文件</p>
<p>如下命令可以解除只读限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -XPUT -H &quot;Content-Type: application/json&quot; http://127.0.0.1:9200/_all/_settings -d &#x27;&#123;&quot;index.blocks.read_only_allow_delete&quot;: false&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>elasticsearch发现磁盘空间大于95%时，将运行于只读状态，此时将不能更新索引，只能查询和删除。</p>
<p>如果还是出现此问题</p>
<p>通过手动重新分配分片，不断执行这个指令，直到unassigned_shards为0，status为green，解决这个问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -XPOST http://127.0.0.1:9200/_cluster/reroute?retry_failed=true</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>RedisDesktop屏蔽更新</title>
    <url>/2023/09/21/RedisDesktop%E5%B1%8F%E8%94%BD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>解压安装完成之后</p>
<p>屏蔽更新</p>
<p>在host文件中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1 rdm.dev</span><br><span class="line">127.0.0.1 redisdesktop.com</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>win</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache防止恶意指向</title>
    <url>/2023/09/21/apache%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<blockquote>
<p>项目中经常有同事提到很多域名恶意指向政府 ip， 导致随意访问哪个域名， 都能浏览政府网， 而那些恶意的域名指向可能会影响电信封掉政府 ip。</p>
</blockquote>
<blockquote>
<p>还有客户发的漏洞报告中【域名访问限制不严格】漏洞，说明：Http请求的Hostname字段没有严格的域名限制，导致可以绕过一些防护措施。修改方法是配置WEB服务器，限制只能以域名形式访问服务器。</p>
</blockquote>
<h6 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h6><p>利用 apache 的跳转功能， 在 VirtualHost 区域添加配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond %&#123;HTTP_HOST&#125; !^(www).xxx.gov.cn [NC]</span><br><span class="line">RewriteCond %&#123;HTTP_HOST&#125; !^(www).xxx1.gov.cn [NC]</span><br><span class="line">RewriteRule ^/(.*) /error.html [L]</span><br></pre></td></tr></table></figure>
<p>说明：写在</VirtualHost>上即可</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 7 对用过yum更新的软件服务进行降级</title>
    <url>/2023/09/21/centos-7-%E5%AF%B9%E7%94%A8%E8%BF%87yum%E6%9B%B4%E6%96%B0%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8C%E9%99%8D%E7%BA%A7/</url>
    <content><![CDATA[<p>　　centos 7 执行 yum update 会对现有服务软件进行更新，但是如果把不该升级的软件升级，彼此软件不兼容，如何进行降级，比如：kibana 必须与 elasticsearch 大版本相同，否则服务不匹配（所以centos 中不是必要不要在已经运行的服务中yum update）<br>　　服务现安装 elasticsearch（5.5.3），但是因为执行 yum update，kibana 由 5.5.3 到 7.3.2</p>
<ol>
<li>查看机器上相近的版本，是否有可选的软件包</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum search --showduplicates kibana</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过查询出指定的软件全名，通过 downgrade 进行升级</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum downgrade kibana-5.5.3-1</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果降级是大版本，可通过修改yum源配置进行大版本降级</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/kibana.repo</span><br><span class="line">[kibana-5.x]name=Kibana repository for5.x packagesbaseurl=https://artifacts.elastic.co/packages/5.x/yumgpgcheck=1gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearchenabled=1autorefresh=1type=rpm-md</span><br></pre></td></tr></table></figure>

<p>  　　然后重新执行步骤1和步骤2</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux批量查找与替换</title>
    <url>/2023/09/21/Linux%E6%89%B9%E9%87%8F%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%9B%BF%E6%8D%A2/</url>
    <content><![CDATA[<p>经常要使用到 Linux 的批量查找与替换，这里我们为大家介绍使用 <strong>sed</strong> 命令来实现查找文件中的内容并替换。</p>
<p><strong>语法格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &quot;s/原字符串/新字符串/g&quot; `grep 原字符串 -rl 所在目录`</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<p>以下我们实现在当前目录下查找包含 baidu 的字符串，并将字符串 baidu 替换为 runoob，执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &quot;s/baidu/runoob/g&quot; `grep &quot;baidu&quot; -rl ./`</span><br></pre></td></tr></table></figure>

<p>接下来使用一个更复杂实例，批量替换网址 libs.baidu.com 为 cdn.static.runoob.com：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &quot;s/https:\/\/libs.baidu.com/https:\/\/cdn.static.runoob.com\/libs/g&quot; `grep -rl &quot;libs.baidu.com&quot; ./`</span><br></pre></td></tr></table></figure>

<p>修改   href&#x3D;’<a href="http://www.hanweb.com/">http://www.hanweb.com</a>‘ style&#x3D;’display:none’&gt;Produced By 大汉网络 大汉版通发布系统  这个标签为    href&#x3D;’<a href="http://yjglj.beijing.gov.cn/">http://yjglj.beijing.gov.cn</a>‘ style&#x3D;’display:none’&gt;北京市应急管理局</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &quot;s/&lt;a href=&#x27;http:\/\/www.hanweb.com&#x27; style=&#x27;display:none&#x27;&gt;Produced By 大汉网络 大汉版通发布系统&lt;\/a&gt;/&lt;a href=&#x27;http:\/\/yjglj.beijing.gov.cn&#x27; style=&#x27;display:none&#x27;&gt;北京市应急管理局&lt;\/a&gt;/g&quot; `grep -rl &quot;&lt;a href=&#x27;http:\/\/www.hanweb.com&#x27; style=&#x27;display:none&#x27;&gt;Produced By 大汉网络 大汉版通发布系统&lt;\/a&gt;&quot; ./`</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo友情链接</title>
    <url>/2023/09/19/hexo%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>友情链接</p>
<p>创建友情链接页面<br>前往你的 Hexo 博客的根目录</p>
<p>输入 hexo new page link</p>
<p>你会找到 source&#x2F;link&#x2F;index.md 这个文件</p>
<p>修改这个文件：</p>
<p>记得添加 type: “link”</p>
<hr>
<p>title: 友情链接<br>date: 2018-06-07 22:17:49<br>type: “link”</p>
<hr>
<p>在Hexo博客目录中的 source&#x2F;_data（如果没有 _data 文件夹，请自行创建），创建一个文件 link.yml</p>
<p>例：</p>
<ul>
<li><p><code>class_name: 友情链接</code><br><code>class_desc: 那些人，那些事</code><br><code>link_list:</code></p>
<ul>
<li><code>name: Hexo</code><br><code>link: https://hexo.io/zh-tw/</code><br><code>avatar: https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg</code><br><code>descr: 快速、简单且强大的网志框架</code></li>
</ul>
</li>
<li><p><code>class_name: 网站</code><br><code>class_desc: 值得推荐的网站</code><br><code>link_list:</code></p>
<ul>
<li><code>name: Youtube</code><br><code>link: https://www.youtube.com/</code><br><code>avatar: https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png</code><br><code>descr: 视频网站</code></li>
<li><code>name: Weibo</code><br><code>link: https://www.weibo.com/</code><br><code>avatar: https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png</code><br><code>descr: 中国最大社交分享平台</code></li>
<li><code>name: Twitter</code><br><code>link: https://twitter.com/</code><br><code>avatar: https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png</code><br><code>descr: 社交分享平台</code></li>
</ul>
</li>
</ul>
<p>class_name 和 class_desc 支持 html 格式书写，如不需要，也可以留空。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo常用命令</title>
    <url>/2023/09/19/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>常用命令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hexo g     <span class="comment">//生成静态页面</span></span><br><span class="line">hexo clean <span class="comment">//清除一下缓存</span></span><br><span class="line">hexo s    <span class="comment">//启动本地服务器进行查看</span></span><br><span class="line">hexo d   <span class="comment">//查看后没有问题即可部署到github上</span></span><br></pre></td></tr></table></figure>

<p>新增文章</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;new article&quot;</span></span><br><span class="line">hexo n 文章标题</span><br></pre></td></tr></table></figure>

<p>新增完成之后，md文章路径</p>
<p>E:\OneDrive - Twork\Bolg\blog\source_posts</p>
<p>修改即可</p>
<p><img src="https://image.allcx.eu.org/file/e6f101c6c16c4d1909a99.png"></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo文章页头部配置</title>
    <url>/2023/09/19/hexo%E6%96%87%E7%AB%A0%E9%A1%B5%E5%A4%B4%E9%83%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>全部文章页头部typora标签</p>
<p>写法	解释<br>title	【必需】文章标题<br>date	【必需】文章创建日期<br>updated	【可选】文章更新日期<br>tags	【可选】文章标签<br>categories	【可选】文章分类<br>keywords	【可选】文章关键字<br>description	【可选】文章描述<br>top_img	【可选】文章顶部图片<br>cover	【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false&#x2F;图片地址&#x2F;留空)<br>comments	【可选】显示文章评论模块(默认 true)<br>toc	【可选】显示文章TOC(默认为设置中toc的enable配置)<br>toc_number	【可选】显示toc_number(默认为设置中toc的number配置)<br>toc_style_simple	【可选】显示 toc 简洁模式<br>copyright	【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)<br>copyright_author	【可选】文章版权模块的文章作者<br>copyright_author_href	【可选】文章版权模块的文章作者链接<br>copyright_url	【可选】文章版权模块的文章连结链接<br>copyright_info	【可选】文章版权模块的版权声明文字<br>mathjax	【可选】显示mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false )<br>katex	【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false )<br>aplayer	【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置<br>highlight_shrink	【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中 highlight_shrink 的配置)<br>aside	【可选】显示侧边栏 (默认 true)</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo页面头部配置</title>
    <url>/2023/09/19/hexo%E9%A1%B5%E9%9D%A2%E5%A4%B4%E9%83%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>全部页面头部typora标签</p>
<p>写法	解释<br>title	【必需】页面标题<br>date	【必需】页面创建日期<br>type	【必需】标签、分类和友情链接三个页面需要配置<br>updated	【可选】页面更新日期<br>description	【可选】页面描述<br>keywords	【可选】页面关键字<br>comments	【可选】显示页面评论模块 (默认 true)<br>top_img	【可选】页面顶部图片<br>mathjax	【可选】显示mathjax (当设置mathjax的per_page: false时，才需要配置，默认 false)<br>katex	【可选】显示katex (当设置katex的per_page: false时，才需要配置，默认 false)<br>aside	【可选】显示侧边栏 (默认 true)<br>aplayer	【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置<br>highlight_shrink	【可选】配置代码框是否展开 (true&#x2F;false) (默认为设置中highlight_shrink的配置)<br>random	【可选】配置友情链接是否随机排序（默认为 false)</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本中执行时提示没有那个文件或目录的解决办法</title>
    <url>/2023/09/21/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E6%89%A7%E8%A1%8C%E6%97%B6%E6%8F%90%E7%A4%BA%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B8%AA%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>出现bad interpreter:No such file or directory的原因，是文件格式的问题。这个文件是在Windows下编写的。换行的方式与Unix不一样，但是在vim下面如果不Set一下又完全看不出来。</p>
<p>问题原因：</p>
<p>因为操作系统是windows，在windows下编辑的脚本，所以有可能有不可见字符。脚本文件是DOS格式的</p>
<p>即每一行的行尾以\r\n来标识, 其ASCII码分别是0x0D, 0x0A.</p>
<p>解决方法：</p>
<p>可以有很多种办法看这个文件是DOS格式的还是UNIX格式的, 还是MAC格式的</p>
<p>（1） vim filename</p>
<p>然后用命令 :set ff</p>
<p>可看到dos或unix的字样，如果的确是dos格式的, 那么用set ff&#x3D;unix把它强制为unix格式的,，然后存盘退出后就可运行。</p>
<p>转换不同平台的文本文件格式可以用</p>
<ol>
<li>unix2dos或dos2unix这两个小程序来做. 很简单. 在djgpp中这两个程序的名字叫dtou和utod, u代表unix, d代表dos</li>
<li>也可以用sed 这样的工具来做:</li>
</ol>
<p>复制代码 代码如下:</p>
<p>sed ‘s&#x2F;^M&#x2F;&#x2F;‘ filename &gt; tmp_filename</p>
<p>mv -f tmp_filename filename</p>
<p>特别说明：^M并不是按键shift + 6产生的^和字母M, 它是一个字符, 其ASCII是0x0D, 生成它的办法是先按CTRL+V, 然后再回车(或CTRL+M)</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode插件</title>
    <url>/2023/09/19/vscode%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>链接原地址:<a href="https://www.cnblogs.com/vivaxiaonan/p/7380099.html">https://www.cnblogs.com/vivaxiaonan/p/7380099.html</a></p>
<p> 格式化文档 shift+alt+f</p>
<p>先按Ctrl+F打开搜索框，然后搜索要编辑的内容，接着按Ctrl+Shift+L就可以选中对应的所有内容了，然后可以全部编辑和替换了。按了Ctrl+shift+L之后把搜索框关闭就可以同时编辑多处了。</p>
<p>自动换行设置</p>
<p>File&gt;&gt;Preferences&gt;&gt;settings&gt;&gt;UserSettings&gt;&gt;CommonlyUsed&gt;&gt;找到Editor:WordWrap,将off修改为on即可</p>
<p>vscode搜索多个文件，同时替换    ctrl+shift+h</p>
<p>VScode现在已经越来越完善。性能远超Atom和webstorm,你有什么理由不用它?</p>
<p>在这里，我会给你们推荐很多实用的插件，让你对 vscode 有更深刻的体会，渐渐地你就会知道它有多好用。</p>
<p>走马观花前，请先将你的 vscode 更新到最新版本。</p>
<p><strong>通用插件</strong></p>
<p><strong>HTML Snippets</strong></p>
<p>超级实用且初级的 H5代码片段以及提示</p>
<p><strong>HTML CSS Support</strong></p>
<p>让 html 标签上写class 智能提示当前项目所支持的样式</p>
<p>新版已经支持scss文件检索</p>
<p><strong>Debugger for Chrome</strong></p>
<p>让 vscode 映射 chrome 的 debug功能，静态页面都可以用 vscode 来打断点调试，真666~ </p>
<p>配置稍微复杂一些，哪天心情好我再另写教程吧~</p>
<p><strong>jQuery Code Snippets</strong></p>
<p>jquery 重度患者必须品，废话不多说，上图</p>
<p><strong>vscode-icon</strong></p>
<p>让 vscode 资源树目录加上图标，必备良品！</p>
<p><strong>Path Intellisense</strong></p>
<p>自动路劲补全，默认不带这个功能的，赶紧装</p>
<p><strong>Npm Intellisense</strong></p>
<p>require 时的包提示（最新版的vscode已经集成此功能）</p>
<p><strong>Document this</strong></p>
<p>js 的注释模板 （注意：最新版的vscode已经原生支持）</p>
<p><strong>ESlint</strong></p>
<p>ESlint 接管原生 js 提示，可以自定制提示规则。这个比较高玩，不会的就算了，我之前发过一篇文章 sublime 配置 <a href="https://segmentfault.com/a/1190000004818718">Atom js 语法校验</a>中有提到，他们的配置文件是通用的。</p>
<p><strong>HTMLHint</strong></p>
<p>html代码检测</p>
<p><strong>Project Manager</strong></p>
<p>在多个项目之前快速切换的工具</p>
<p><strong>beautify</strong></p>
<p>格式化代码的工具</p>
<p><strong>Bootstrap 3 Sinnpet</strong></p>
<p>常用 bootstrap 的可以下</p>
<p><strong>Atuo Rename Tag</strong></p>
<p>修改 html 标签，自动帮你完成尾部闭合标签的同步修改，不过有些bug。</p>
<p><strong>GitLens</strong></p>
<p>丰富的git日志插件</p>
<p><strong>fileheader</strong></p>
<p>顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间</p>
<p><strong>filesize</strong></p>
<p>在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间</p>
<p><strong>Bracket Pair Colorizer</strong></p>
<p>让括号拥有独立的颜色，易于区分。可以配合任意主题使用。</p>
<p><strong>Quokka</strong></p>
<p><strong>使用</strong>：先shift+cmd+p （ctrl+shift+p）输入 quokka 选择 new javascript 就行了</p>
<p>Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈。它易于配置，并能够预览变量的函数和计算值结果。另外，在使用 JSX 或 TypeScript 项目中，它能够开箱即用。</p>
<p>&#x2F;<em>?</em>&#x2F;在某个表达式之后（或&#x2F;&#x2F;?在语句之后）插入特殊注释将仅记录该表达式的值。</p>
<p>例如，</p>
<p>a.b()&#x2F;<em>?</em>&#x2F;.c().d()</p>
<p>将输出a.b()表达式的结果，和</p>
<p>a.b().c().d() &#x2F;<em>?</em>&#x2F;&#x2F;&#x2F; or justa.b().c().d() &#x2F;&#x2F;?</p>
<p>将输出完整a.b().c().d()表达式的结果。</p>
<p>&#x2F;<em>?.</em>&#x2F; 在任何表达式之后插入特殊注释将报告执行表达式所花费的时间。</p>
<p>a() &#x2F;&#x2F;?. $    显示a()执行时间和结果。</p>
<p>插件地址：<a href="https://quokkajs.com/">https://quokkajs.com/</a></p>
<p><strong>CSS Peek</strong></p>
<p>使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。</p>
<p>插件地址：</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=pranaygp.vscode-css-peek">https://marketplace.visualstudio.com/items?itemName=pranaygp.vscode-css-peek</a></p>
<p><strong>HTML Boilerplate</strong></p>
<p>通过使用 HTML 模版插件，你就摆脱了为 HTML 新文件重新编写头部和正文标签的苦恼。你只需在空文件中输入 html，并按 Tab 键，即可生成干净的文档结构。</p>
<p>插件地址：</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=sidthesloth.html5-boilerplate">https://marketplace.visualstudio.com/items?itemName=sidthesloth.html5-boilerplate</a></p>
<p><strong>Prettier</strong></p>
<p>Prettier 是目前 Web 开发中最受欢迎的代码格式化程序。安装了这个插件，它就能够自动应用 Prettier，并将整个 JS 和 CSS 文档快速格式化为统一的代码样式。如果你还想使用 ESLint，那么还有个 Prettier – Eslint 插件，你可不要错过咯！</p>
<p>插件地址：</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode</a></p>
<p><strong>Color Info</strong></p>
<p>这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。</p>
<p>插件地址：</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=bierner.color-info">https://marketplace.visualstudio.com/items?itemName=bierner.color-info</a></p>
<p><strong>Icon Fonts</strong></p>
<p>这是一个能够在项目中添加图标字体的插件。该插件支持超过 20 个热门的图标集，包括了 Font Awesome、Ionicons、Glyphicons 和 Material Design Icons。</p>
<p>插件地址：</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=idleberg.icon-fonts">https://marketplace.visualstudio.com/items?itemName=idleberg.icon-fonts</a></p>
<p><strong>Minify</strong></p>
<p>这是一款用于压缩合并 JavaScript 和 CSS 文件的应用程序。它提供了大量自定义的设置，以及自动压缩保存并导出为.min文件的选项。它能够分别通过 uglify-js、clean-css 和 html-minifier，与 JavaScript、CSS 和 HTML 协同工作。</p>
<p>使用<strong>F1</strong>运行文件缩小器Minify</p>
<p>插件地址：</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=HookyQR.minify">https://marketplace.visualstudio.com/items?itemName=HookyQR.minify</a></p>
<p><strong>Vue插件</strong></p>
<p>以下推荐vue框架所需的插件</p>
<p><strong>vetur</strong></p>
<p>语法高亮、智能感知、Emmet等</p>
<p><strong>VueHelper</strong></p>
<p>snippet代码片段</p>
]]></content>
      <tags>
        <tag>win</tag>
      </tags>
  </entry>
  <entry>
    <title>免费使用cloudflare搭建v2之创建Workers</title>
    <url>/2023/09/26/%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8cloudflare%E6%90%AD%E5%BB%BAv2%E4%B9%8B%E5%88%9B%E5%BB%BAWorkers/</url>
    <content><![CDATA[<blockquote>
<p>使用cloudflare中免费的Workers进行搭建，实现免费v2，速度一般，划水基本够用，前提为拥有cloudflare账号以及拥有自己域名。此篇为系列教程第一步</p>
</blockquote>
<h6 id="创建Workers"><a href="#创建Workers" class="headerlink" title="创建Workers"></a>创建Workers</h6><p>登录到cloudflare中，地址为<a href="https://www.cloudflare-cn.com/">Cloudflare</a>，首先点击左侧列表中 Workers 和 Pages ，点击 创建应用程序 </p>
<p><img src="https://image.allcx.eu.org/file/2263583b059f98ce6ecab.png"></p>
<p>然后点击 创建Worker</p>
<p><img src="https://image.allcx.eu.org/file/7d7d39e11dc9467194dc4.png"></p>
<p>名称随便写，然后点击下方部署</p>
<p><img src="https://image.allcx.eu.org/file/09732a2c75ec22405be39.png"></p>
<p>部署完成</p>
]]></content>
      <tags>
        <tag>cloudflare</tag>
      </tags>
  </entry>
  <entry>
    <title>finalshell屏蔽更新</title>
    <url>/2023/09/19/finalshell%E5%B1%8F%E8%94%BD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>#禁止finalshell更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1 www.youtusoft.com</span><br><span class="line"></span><br><span class="line">127.0.0.1 youtusoft.com</span><br><span class="line"></span><br><span class="line">127.0.0.1 hostbuf.com</span><br><span class="line"></span><br><span class="line">127.0.0.1 www.hostbuf.com</span><br><span class="line"></span><br><span class="line">127.0.0.1 dkys.org</span><br><span class="line"></span><br><span class="line">127.0.0.1 tcpspeed.com</span><br><span class="line"></span><br><span class="line">127.0.0.1 www.wn1998.com</span><br><span class="line"></span><br><span class="line">127.0.0.1 wn1998.com</span><br><span class="line"></span><br><span class="line">127.0.0.1 pwlt.wn1998.com</span><br><span class="line"></span><br><span class="line">127.0.0.1 backup.[www.hostbuf.com](http://www.hostbuf.com)</span><br></pre></td></tr></table></figure>

<p>本机host添加以上配置即可</p>
]]></content>
      <tags>
        <tag>win</tag>
      </tags>
  </entry>
  <entry>
    <title>免费使用cloudflare搭建v2之部署代码</title>
    <url>/2023/09/26/%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8cloudflare%E6%90%AD%E5%BB%BAv2%E4%B9%8B%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p>使用cloudflare中免费的Workers进行搭建，实现免费v2，速度一般，划水基本够用，前提为拥有cloudflare账号以及拥有自己域名。此篇为系列教程第二步</p>
</blockquote>
<h6 id="部署代码"><a href="#部署代码" class="headerlink" title="部署代码"></a>部署代码</h6><p>部署完成后如图</p>
<p><img src="https://image.allcx.eu.org/file/ae0cc32230c6f6761c533.png"></p>
<p>点击编辑代码，把默认代码全部删除，</p>
<p><img src="https://image.allcx.eu.org/file/4bd453ac01fc09acd973f.png"></p>
<p>删除之后，复制如下代码并粘贴到上面默认代码的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// &lt;!--GAMFC--&gt;version base on commit 43fad05dcdae3b723c53c226f8181fc5bd47223e, time is 2023-06-22 15:20:02 UTC&lt;!--GAMFC-END--&gt;.</span><br><span class="line">// @ts-ignore</span><br><span class="line">import &#123; connect &#125; from &#x27;cloudflare:sockets&#x27;;</span><br><span class="line"></span><br><span class="line">// How to generate your own UUID:</span><br><span class="line">// [Windows] Press &quot;Win + R&quot;, input cmd and run:  Powershell -NoExit -Command &quot;[guid]::NewGuid()&quot;</span><br><span class="line">let userID = &#x27;15257580-2329-4e85-b8f5-4faf0204a40d&#x27;;</span><br><span class="line"></span><br><span class="line">let proxyIP = &#x27;47.245.53.50&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (!isValidUUID(userID)) &#123;</span><br><span class="line">	throw new Error(&#x27;uuid is not valid&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * @param &#123;import(&quot;@cloudflare/workers-types&quot;).Request&#125; request</span><br><span class="line">	 * @param &#123;&#123;UUID: string, PROXYIP: string&#125;&#125; env</span><br><span class="line">	 * @param &#123;import(&quot;@cloudflare/workers-types&quot;).ExecutionContext&#125; ctx</span><br><span class="line">	 * @returns &#123;Promise&lt;Response&gt;&#125;</span><br><span class="line">	 */</span><br><span class="line">	async fetch(request, env, ctx) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			userID = env.UUID || userID;</span><br><span class="line">			proxyIP = env.PROXYIP || proxyIP;</span><br><span class="line">			const upgradeHeader = request.headers.get(&#x27;Upgrade&#x27;);</span><br><span class="line">			if (!upgradeHeader || upgradeHeader !== &#x27;websocket&#x27;) &#123;</span><br><span class="line">				const url = new URL(request.url);</span><br><span class="line">				switch (url.pathname) &#123;</span><br><span class="line">					case &#x27;/&#x27;:</span><br><span class="line">						return new Response(JSON.stringify(request.cf), &#123; status: 200 &#125;);</span><br><span class="line">					case `/$&#123;userID&#125;`: &#123;</span><br><span class="line">						const vlessConfig = getVLESSConfig(userID, request.headers.get(&#x27;Host&#x27;));</span><br><span class="line">						return new Response(`$&#123;vlessConfig&#125;`, &#123;</span><br><span class="line">							status: 200,</span><br><span class="line">							headers: &#123;</span><br><span class="line">								&quot;Content-Type&quot;: &quot;text/plain;charset=utf-8&quot;,</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line">					&#125;</span><br><span class="line">					default:</span><br><span class="line">						return new Response(&#x27;Not found&#x27;, &#123; status: 404 &#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return await vlessOverWSHandler(request);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (err) &#123;</span><br><span class="line">			/** @type &#123;Error&#125; */ let e = err;</span><br><span class="line">			return new Response(e.toString());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;import(&quot;@cloudflare/workers-types&quot;).Request&#125; request</span><br><span class="line"> */</span><br><span class="line">async function vlessOverWSHandler(request) &#123;</span><br><span class="line"></span><br><span class="line">	/** @type &#123;import(&quot;@cloudflare/workers-types&quot;).WebSocket[]&#125; */</span><br><span class="line">	// @ts-ignore</span><br><span class="line">	const webSocketPair = new WebSocketPair();</span><br><span class="line">	const [client, webSocket] = Object.values(webSocketPair);</span><br><span class="line"></span><br><span class="line">	webSocket.accept();</span><br><span class="line"></span><br><span class="line">	let address = &#x27;&#x27;;</span><br><span class="line">	let portWithRandomLog = &#x27;&#x27;;</span><br><span class="line">	const log = (/** @type &#123;string&#125; */ info, /** @type &#123;string | undefined&#125; */ event) =&gt; &#123;</span><br><span class="line">		console.log(`[$&#123;address&#125;:$&#123;portWithRandomLog&#125;] $&#123;info&#125;`, event || &#x27;&#x27;);</span><br><span class="line">	&#125;;</span><br><span class="line">	const earlyDataHeader = request.headers.get(&#x27;sec-websocket-protocol&#x27;) || &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">	const readableWebSocketStream = makeReadableWebSocketStream(webSocket, earlyDataHeader, log);</span><br><span class="line"></span><br><span class="line">	/** @type &#123;&#123; value: import(&quot;@cloudflare/workers-types&quot;).Socket | null&#125;&#125;*/</span><br><span class="line">	let remoteSocketWapper = &#123;</span><br><span class="line">		value: null,</span><br><span class="line">	&#125;;</span><br><span class="line">	let udpStreamWrite = null;</span><br><span class="line">	let isDns = false;</span><br><span class="line"></span><br><span class="line">	// ws --&gt; remote</span><br><span class="line">	readableWebSocketStream.pipeTo(new WritableStream(&#123;</span><br><span class="line">		async write(chunk, controller) &#123;</span><br><span class="line">			if (isDns &amp;&amp; udpStreamWrite) &#123;</span><br><span class="line">				return udpStreamWrite(chunk);</span><br><span class="line">			&#125;</span><br><span class="line">			if (remoteSocketWapper.value) &#123;</span><br><span class="line">				const writer = remoteSocketWapper.value.writable.getWriter()</span><br><span class="line">				await writer.write(chunk);</span><br><span class="line">				writer.releaseLock();</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			const &#123;</span><br><span class="line">				hasError,</span><br><span class="line">				message,</span><br><span class="line">				portRemote = 443,</span><br><span class="line">				addressRemote = &#x27;&#x27;,</span><br><span class="line">				rawDataIndex,</span><br><span class="line">				vlessVersion = new Uint8Array([0, 0]),</span><br><span class="line">				isUDP,</span><br><span class="line">			&#125; = processVlessHeader(chunk, userID);</span><br><span class="line">			address = addressRemote;</span><br><span class="line">			portWithRandomLog = `$&#123;portRemote&#125;--$&#123;Math.random()&#125; $&#123;isUDP ? &#x27;udp &#x27; : &#x27;tcp &#x27;</span><br><span class="line">				&#125; `;</span><br><span class="line">			if (hasError) &#123;</span><br><span class="line">				// controller.error(message);</span><br><span class="line">				throw new Error(message); // cf seems has bug, controller.error will not end stream</span><br><span class="line">				// webSocket.close(1000, message);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			// if UDP but port not DNS port, close it</span><br><span class="line">			if (isUDP) &#123;</span><br><span class="line">				if (portRemote === 53) &#123;</span><br><span class="line">					isDns = true;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					// controller.error(&#x27;UDP proxy only enable for DNS which is port 53&#x27;);</span><br><span class="line">					throw new Error(&#x27;UDP proxy only enable for DNS which is port 53&#x27;); // cf seems has bug, controller.error will not end stream</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			// [&quot;version&quot;, &quot;附加信息长度 N&quot;]</span><br><span class="line">			const vlessResponseHeader = new Uint8Array([vlessVersion[0], 0]);</span><br><span class="line">			const rawClientData = chunk.slice(rawDataIndex);</span><br><span class="line"></span><br><span class="line">			// TODO: support udp here when cf runtime has udp support</span><br><span class="line">			if (isDns) &#123;</span><br><span class="line">				const &#123; write &#125; = await handleUDPOutBound(webSocket, vlessResponseHeader, log);</span><br><span class="line">				udpStreamWrite = write;</span><br><span class="line">				udpStreamWrite(rawClientData);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			handleTCPOutBound(remoteSocketWapper, addressRemote, portRemote, rawClientData, webSocket, vlessResponseHeader, log);</span><br><span class="line">		&#125;,</span><br><span class="line">		close() &#123;</span><br><span class="line">			log(`readableWebSocketStream is close`);</span><br><span class="line">		&#125;,</span><br><span class="line">		abort(reason) &#123;</span><br><span class="line">			log(`readableWebSocketStream is abort`, JSON.stringify(reason));</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)).catch((err) =&gt; &#123;</span><br><span class="line">		log(&#x27;readableWebSocketStream pipeTo error&#x27;, err);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	return new Response(null, &#123;</span><br><span class="line">		status: 101,</span><br><span class="line">		// @ts-ignore</span><br><span class="line">		webSocket: client,</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Handles outbound TCP connections.</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;any&#125; remoteSocket </span><br><span class="line"> * @param &#123;string&#125; addressRemote The remote address to connect to.</span><br><span class="line"> * @param &#123;number&#125; portRemote The remote port to connect to.</span><br><span class="line"> * @param &#123;Uint8Array&#125; rawClientData The raw client data to write.</span><br><span class="line"> * @param &#123;import(&quot;@cloudflare/workers-types&quot;).WebSocket&#125; webSocket The WebSocket to pass the remote socket to.</span><br><span class="line"> * @param &#123;Uint8Array&#125; vlessResponseHeader The VLESS response header.</span><br><span class="line"> * @param &#123;function&#125; log The logging function.</span><br><span class="line"> * @returns &#123;Promise&lt;void&gt;&#125; The remote socket.</span><br><span class="line"> */</span><br><span class="line">async function handleTCPOutBound(remoteSocket, addressRemote, portRemote, rawClientData, webSocket, vlessResponseHeader, log,) &#123;</span><br><span class="line">	async function connectAndWrite(address, port) &#123;</span><br><span class="line">		/** @type &#123;import(&quot;@cloudflare/workers-types&quot;).Socket&#125; */</span><br><span class="line">		const tcpSocket = connect(&#123;</span><br><span class="line">			hostname: address,</span><br><span class="line">			port: port,</span><br><span class="line">		&#125;);</span><br><span class="line">		remoteSocket.value = tcpSocket;</span><br><span class="line">		log(`connected to $&#123;address&#125;:$&#123;port&#125;`);</span><br><span class="line">		const writer = tcpSocket.writable.getWriter();</span><br><span class="line">		await writer.write(rawClientData); // first write, nomal is tls client hello</span><br><span class="line">		writer.releaseLock();</span><br><span class="line">		return tcpSocket;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// if the cf connect tcp socket have no incoming data, we retry to redirect ip</span><br><span class="line">	async function retry() &#123;</span><br><span class="line">		const tcpSocket = await connectAndWrite(proxyIP || addressRemote, portRemote)</span><br><span class="line">		// no matter retry success or not, close websocket</span><br><span class="line">		tcpSocket.closed.catch(error =&gt; &#123;</span><br><span class="line">			console.log(&#x27;retry tcpSocket closed error&#x27;, error);</span><br><span class="line">		&#125;).finally(() =&gt; &#123;</span><br><span class="line">			safeCloseWebSocket(webSocket);</span><br><span class="line">		&#125;)</span><br><span class="line">		remoteSocketToWS(tcpSocket, webSocket, vlessResponseHeader, null, log);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	const tcpSocket = await connectAndWrite(addressRemote, portRemote);</span><br><span class="line"></span><br><span class="line">	// when remoteSocket is ready, pass to websocket</span><br><span class="line">	// remote--&gt; ws</span><br><span class="line">	remoteSocketToWS(tcpSocket, webSocket, vlessResponseHeader, retry, log);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;import(&quot;@cloudflare/workers-types&quot;).WebSocket&#125; webSocketServer</span><br><span class="line"> * @param &#123;string&#125; earlyDataHeader for ws 0rtt</span><br><span class="line"> * @param &#123;(info: string)=&gt; void&#125; log for ws 0rtt</span><br><span class="line"> */</span><br><span class="line">function makeReadableWebSocketStream(webSocketServer, earlyDataHeader, log) &#123;</span><br><span class="line">	let readableStreamCancel = false;</span><br><span class="line">	const stream = new ReadableStream(&#123;</span><br><span class="line">		start(controller) &#123;</span><br><span class="line">			webSocketServer.addEventListener(&#x27;message&#x27;, (event) =&gt; &#123;</span><br><span class="line">				if (readableStreamCancel) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">				const message = event.data;</span><br><span class="line">				controller.enqueue(message);</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			// The event means that the client closed the client -&gt; server stream.</span><br><span class="line">			// However, the server -&gt; client stream is still open until you call close() on the server side.</span><br><span class="line">			// The WebSocket protocol says that a separate close message must be sent in each direction to fully close the socket.</span><br><span class="line">			webSocketServer.addEventListener(&#x27;close&#x27;, () =&gt; &#123;</span><br><span class="line">				// client send close, need close server</span><br><span class="line">				// if stream is cancel, skip controller.close</span><br><span class="line">				safeCloseWebSocket(webSocketServer);</span><br><span class="line">				if (readableStreamCancel) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">				controller.close();</span><br><span class="line">			&#125;</span><br><span class="line">			);</span><br><span class="line">			webSocketServer.addEventListener(&#x27;error&#x27;, (err) =&gt; &#123;</span><br><span class="line">				log(&#x27;webSocketServer has error&#x27;);</span><br><span class="line">				controller.error(err);</span><br><span class="line">			&#125;</span><br><span class="line">			);</span><br><span class="line">			// for ws 0rtt</span><br><span class="line">			const &#123; earlyData, error &#125; = base64ToArrayBuffer(earlyDataHeader);</span><br><span class="line">			if (error) &#123;</span><br><span class="line">				controller.error(error);</span><br><span class="line">			&#125; else if (earlyData) &#123;</span><br><span class="line">				controller.enqueue(earlyData);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line"></span><br><span class="line">		pull(controller) &#123;</span><br><span class="line">			// if ws can stop read if stream is full, we can implement backpressure</span><br><span class="line">			// https://streams.spec.whatwg.org/#example-rs-push-backpressure</span><br><span class="line">		&#125;,</span><br><span class="line">		cancel(reason) &#123;</span><br><span class="line">			// 1. pipe WritableStream has error, this cancel will called, so ws handle server close into here</span><br><span class="line">			// 2. if readableStream is cancel, all controller.close/enqueue need skip,</span><br><span class="line">			// 3. but from testing controller.error still work even if readableStream is cancel</span><br><span class="line">			if (readableStreamCancel) &#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			log(`ReadableStream was canceled, due to $&#123;reason&#125;`)</span><br><span class="line">			readableStreamCancel = true;</span><br><span class="line">			safeCloseWebSocket(webSocketServer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	return stream;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// https://xtls.github.io/development/protocols/vless.html</span><br><span class="line">// https://github.com/zizifn/excalidraw-backup/blob/main/v2ray-protocol.excalidraw</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123; ArrayBuffer&#125; vlessBuffer </span><br><span class="line"> * @param &#123;string&#125; userID </span><br><span class="line"> * @returns </span><br><span class="line"> */</span><br><span class="line">function processVlessHeader(</span><br><span class="line">	vlessBuffer,</span><br><span class="line">	userID</span><br><span class="line">) &#123;</span><br><span class="line">	if (vlessBuffer.byteLength &lt; 24) &#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			hasError: true,</span><br><span class="line">			message: &#x27;invalid data&#x27;,</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	const version = new Uint8Array(vlessBuffer.slice(0, 1));</span><br><span class="line">	let isValidUser = false;</span><br><span class="line">	let isUDP = false;</span><br><span class="line">	if (stringify(new Uint8Array(vlessBuffer.slice(1, 17))) === userID) &#123;</span><br><span class="line">		isValidUser = true;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!isValidUser) &#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			hasError: true,</span><br><span class="line">			message: &#x27;invalid user&#x27;,</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	const optLength = new Uint8Array(vlessBuffer.slice(17, 18))[0];</span><br><span class="line">	//skip opt for now</span><br><span class="line"></span><br><span class="line">	const command = new Uint8Array(</span><br><span class="line">		vlessBuffer.slice(18 + optLength, 18 + optLength + 1)</span><br><span class="line">	)[0];</span><br><span class="line"></span><br><span class="line">	// 0x01 TCP</span><br><span class="line">	// 0x02 UDP</span><br><span class="line">	// 0x03 MUX</span><br><span class="line">	if (command === 1) &#123;</span><br><span class="line">	&#125; else if (command === 2) &#123;</span><br><span class="line">		isUDP = true;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			hasError: true,</span><br><span class="line">			message: `command $&#123;command&#125; is not support, command 01-tcp,02-udp,03-mux`,</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	const portIndex = 18 + optLength + 1;</span><br><span class="line">	const portBuffer = vlessBuffer.slice(portIndex, portIndex + 2);</span><br><span class="line">	// port is big-Endian in raw data etc 80 == 0x005d</span><br><span class="line">	const portRemote = new DataView(portBuffer).getUint16(0);</span><br><span class="line"></span><br><span class="line">	let addressIndex = portIndex + 2;</span><br><span class="line">	const addressBuffer = new Uint8Array(</span><br><span class="line">		vlessBuffer.slice(addressIndex, addressIndex + 1)</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	// 1--&gt; ipv4  addressLength =4</span><br><span class="line">	// 2--&gt; domain name addressLength=addressBuffer[1]</span><br><span class="line">	// 3--&gt; ipv6  addressLength =16</span><br><span class="line">	const addressType = addressBuffer[0];</span><br><span class="line">	let addressLength = 0;</span><br><span class="line">	let addressValueIndex = addressIndex + 1;</span><br><span class="line">	let addressValue = &#x27;&#x27;;</span><br><span class="line">	switch (addressType) &#123;</span><br><span class="line">		case 1:</span><br><span class="line">			addressLength = 4;</span><br><span class="line">			addressValue = new Uint8Array(</span><br><span class="line">				vlessBuffer.slice(addressValueIndex, addressValueIndex + addressLength)</span><br><span class="line">			).join(&#x27;.&#x27;);</span><br><span class="line">			break;</span><br><span class="line">		case 2:</span><br><span class="line">			addressLength = new Uint8Array(</span><br><span class="line">				vlessBuffer.slice(addressValueIndex, addressValueIndex + 1)</span><br><span class="line">			)[0];</span><br><span class="line">			addressValueIndex += 1;</span><br><span class="line">			addressValue = new TextDecoder().decode(</span><br><span class="line">				vlessBuffer.slice(addressValueIndex, addressValueIndex + addressLength)</span><br><span class="line">			);</span><br><span class="line">			break;</span><br><span class="line">		case 3:</span><br><span class="line">			addressLength = 16;</span><br><span class="line">			const dataView = new DataView(</span><br><span class="line">				vlessBuffer.slice(addressValueIndex, addressValueIndex + addressLength)</span><br><span class="line">			);</span><br><span class="line">			// 2001:0db8:85a3:0000:0000:8a2e:0370:7334</span><br><span class="line">			const ipv6 = [];</span><br><span class="line">			for (let i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">				ipv6.push(dataView.getUint16(i * 2).toString(16));</span><br><span class="line">			&#125;</span><br><span class="line">			addressValue = ipv6.join(&#x27;:&#x27;);</span><br><span class="line">			// seems no need add [] for ipv6</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			return &#123;</span><br><span class="line">				hasError: true,</span><br><span class="line">				message: `invild  addressType is $&#123;addressType&#125;`,</span><br><span class="line">			&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!addressValue) &#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			hasError: true,</span><br><span class="line">			message: `addressValue is empty, addressType is $&#123;addressType&#125;`,</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return &#123;</span><br><span class="line">		hasError: false,</span><br><span class="line">		addressRemote: addressValue,</span><br><span class="line">		addressType,</span><br><span class="line">		portRemote,</span><br><span class="line">		rawDataIndex: addressValueIndex + addressLength,</span><br><span class="line">		vlessVersion: version,</span><br><span class="line">		isUDP,</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;import(&quot;@cloudflare/workers-types&quot;).Socket&#125; remoteSocket </span><br><span class="line"> * @param &#123;import(&quot;@cloudflare/workers-types&quot;).WebSocket&#125; webSocket </span><br><span class="line"> * @param &#123;ArrayBuffer&#125; vlessResponseHeader </span><br><span class="line"> * @param &#123;(() =&gt; Promise&lt;void&gt;) | null&#125; retry</span><br><span class="line"> * @param &#123;*&#125; log </span><br><span class="line"> */</span><br><span class="line">async function remoteSocketToWS(remoteSocket, webSocket, vlessResponseHeader, retry, log) &#123;</span><br><span class="line">	// remote--&gt; ws</span><br><span class="line">	let remoteChunkCount = 0;</span><br><span class="line">	let chunks = [];</span><br><span class="line">	/** @type &#123;ArrayBuffer | null&#125; */</span><br><span class="line">	let vlessHeader = vlessResponseHeader;</span><br><span class="line">	let hasIncomingData = false; // check if remoteSocket has incoming data</span><br><span class="line">	await remoteSocket.readable</span><br><span class="line">		.pipeTo(</span><br><span class="line">			new WritableStream(&#123;</span><br><span class="line">				start() &#123;</span><br><span class="line">				&#125;,</span><br><span class="line">				/**</span><br><span class="line">				 * </span><br><span class="line">				 * @param &#123;Uint8Array&#125; chunk </span><br><span class="line">				 * @param &#123;*&#125; controller </span><br><span class="line">				 */</span><br><span class="line">				async write(chunk, controller) &#123;</span><br><span class="line">					hasIncomingData = true;</span><br><span class="line">					// remoteChunkCount++;</span><br><span class="line">					if (webSocket.readyState !== WS_READY_STATE_OPEN) &#123;</span><br><span class="line">						controller.error(</span><br><span class="line">							&#x27;webSocket.readyState is not open, maybe close&#x27;</span><br><span class="line">						);</span><br><span class="line">					&#125;</span><br><span class="line">					if (vlessHeader) &#123;</span><br><span class="line">						webSocket.send(await new Blob([vlessHeader, chunk]).arrayBuffer());</span><br><span class="line">						vlessHeader = null;</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						// seems no need rate limit this, CF seems fix this??..</span><br><span class="line">						// if (remoteChunkCount &gt; 20000) &#123;</span><br><span class="line">						// 	// cf one package is 4096 byte(4kb),  4096 * 20000 = 80M</span><br><span class="line">						// 	await delay(1);</span><br><span class="line">						// &#125;</span><br><span class="line">						webSocket.send(chunk);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				close() &#123;</span><br><span class="line">					log(`remoteConnection!.readable is close with hasIncomingData is $&#123;hasIncomingData&#125;`);</span><br><span class="line">					// safeCloseWebSocket(webSocket); // no need server close websocket frist for some case will casue HTTP ERR_CONTENT_LENGTH_MISMATCH issue, client will send close event anyway.</span><br><span class="line">				&#125;,</span><br><span class="line">				abort(reason) &#123;</span><br><span class="line">					console.error(`remoteConnection!.readable abort`, reason);</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;)</span><br><span class="line">		)</span><br><span class="line">		.catch((error) =&gt; &#123;</span><br><span class="line">			console.error(</span><br><span class="line">				`remoteSocketToWS has exception `,</span><br><span class="line">				error.stack || error</span><br><span class="line">			);</span><br><span class="line">			safeCloseWebSocket(webSocket);</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	// seems is cf connect socket have error,</span><br><span class="line">	// 1. Socket.closed will have error</span><br><span class="line">	// 2. Socket.readable will be close without any data coming</span><br><span class="line">	if (hasIncomingData === false &amp;&amp; retry) &#123;</span><br><span class="line">		log(`retry`)</span><br><span class="line">		retry();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;string&#125; base64Str </span><br><span class="line"> * @returns </span><br><span class="line"> */</span><br><span class="line">function base64ToArrayBuffer(base64Str) &#123;</span><br><span class="line">	if (!base64Str) &#123;</span><br><span class="line">		return &#123; error: null &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		// go use modified Base64 for URL rfc4648 which js atob not support</span><br><span class="line">		base64Str = base64Str.replace(/-/g, &#x27;+&#x27;).replace(/_/g, &#x27;/&#x27;);</span><br><span class="line">		const decode = atob(base64Str);</span><br><span class="line">		const arryBuffer = Uint8Array.from(decode, (c) =&gt; c.charCodeAt(0));</span><br><span class="line">		return &#123; earlyData: arryBuffer.buffer, error: null &#125;;</span><br><span class="line">	&#125; catch (error) &#123;</span><br><span class="line">		return &#123; error &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * This is not real UUID validation</span><br><span class="line"> * @param &#123;string&#125; uuid </span><br><span class="line"> */</span><br><span class="line">function isValidUUID(uuid) &#123;</span><br><span class="line">	const uuidRegex = /^[0-9a-f]&#123;8&#125;-[0-9a-f]&#123;4&#125;-[4][0-9a-f]&#123;3&#125;-[89ab][0-9a-f]&#123;3&#125;-[0-9a-f]&#123;12&#125;$/i;</span><br><span class="line">	return uuidRegex.test(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const WS_READY_STATE_OPEN = 1;</span><br><span class="line">const WS_READY_STATE_CLOSING = 2;</span><br><span class="line">/**</span><br><span class="line"> * Normally, WebSocket will not has exceptions when close.</span><br><span class="line"> * @param &#123;import(&quot;@cloudflare/workers-types&quot;).WebSocket&#125; socket</span><br><span class="line"> */</span><br><span class="line">function safeCloseWebSocket(socket) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		if (socket.readyState === WS_READY_STATE_OPEN || socket.readyState === WS_READY_STATE_CLOSING) &#123;</span><br><span class="line">			socket.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; catch (error) &#123;</span><br><span class="line">		console.error(&#x27;safeCloseWebSocket error&#x27;, error);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const byteToHex = [];</span><br><span class="line">for (let i = 0; i &lt; 256; ++i) &#123;</span><br><span class="line">	byteToHex.push((i + 256).toString(16).slice(1));</span><br><span class="line">&#125;</span><br><span class="line">function unsafeStringify(arr, offset = 0) &#123;</span><br><span class="line">	return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + &quot;-&quot; + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + &quot;-&quot; + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + &quot;-&quot; + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + &quot;-&quot; + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();</span><br><span class="line">&#125;</span><br><span class="line">function stringify(arr, offset = 0) &#123;</span><br><span class="line">	const uuid = unsafeStringify(arr, offset);</span><br><span class="line">	if (!isValidUUID(uuid)) &#123;</span><br><span class="line">		throw TypeError(&quot;Stringified UUID is invalid&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return uuid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;import(&quot;@cloudflare/workers-types&quot;).WebSocket&#125; webSocket </span><br><span class="line"> * @param &#123;ArrayBuffer&#125; vlessResponseHeader </span><br><span class="line"> * @param &#123;(string)=&gt; void&#125; log </span><br><span class="line"> */</span><br><span class="line">async function handleUDPOutBound(webSocket, vlessResponseHeader, log) &#123;</span><br><span class="line"></span><br><span class="line">	let isVlessHeaderSent = false;</span><br><span class="line">	const transformStream = new TransformStream(&#123;</span><br><span class="line">		start(controller) &#123;</span><br><span class="line"></span><br><span class="line">		&#125;,</span><br><span class="line">		transform(chunk, controller) &#123;</span><br><span class="line">			// udp message 2 byte is the the length of udp data</span><br><span class="line">			// TODO: this should have bug, beacsue maybe udp chunk can be in two websocket message</span><br><span class="line">			for (let index = 0; index &lt; chunk.byteLength;) &#123;</span><br><span class="line">				const lengthBuffer = chunk.slice(index, index + 2);</span><br><span class="line">				const udpPakcetLength = new DataView(lengthBuffer).getUint16(0);</span><br><span class="line">				const udpData = new Uint8Array(</span><br><span class="line">					chunk.slice(index + 2, index + 2 + udpPakcetLength)</span><br><span class="line">				);</span><br><span class="line">				index = index + 2 + udpPakcetLength;</span><br><span class="line">				controller.enqueue(udpData);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		flush(controller) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	// only handle dns udp for now</span><br><span class="line">	transformStream.readable.pipeTo(new WritableStream(&#123;</span><br><span class="line">		async write(chunk) &#123;</span><br><span class="line">			const resp = await fetch(&#x27;https://1.1.1.1/dns-query&#x27;,</span><br><span class="line">				&#123;</span><br><span class="line">					method: &#x27;POST&#x27;,</span><br><span class="line">					headers: &#123;</span><br><span class="line">						&#x27;content-type&#x27;: &#x27;application/dns-message&#x27;,</span><br><span class="line">					&#125;,</span><br><span class="line">					body: chunk,</span><br><span class="line">				&#125;)</span><br><span class="line">			const dnsQueryResult = await resp.arrayBuffer();</span><br><span class="line">			const udpSize = dnsQueryResult.byteLength;</span><br><span class="line">			// console.log([...new Uint8Array(dnsQueryResult)].map((x) =&gt; x.toString(16)));</span><br><span class="line">			const udpSizeBuffer = new Uint8Array([(udpSize &gt;&gt; 8) &amp; 0xff, udpSize &amp; 0xff]);</span><br><span class="line">			if (webSocket.readyState === WS_READY_STATE_OPEN) &#123;</span><br><span class="line">				log(`doh success and dns message length is $&#123;udpSize&#125;`);</span><br><span class="line">				if (isVlessHeaderSent) &#123;</span><br><span class="line">					webSocket.send(await new Blob([udpSizeBuffer, dnsQueryResult]).arrayBuffer());</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					webSocket.send(await new Blob([vlessResponseHeader, udpSizeBuffer, dnsQueryResult]).arrayBuffer());</span><br><span class="line">					isVlessHeaderSent = true;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)).catch((error) =&gt; &#123;</span><br><span class="line">		log(&#x27;dns udp has error&#x27; + error)</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	const writer = transformStream.writable.getWriter();</span><br><span class="line"></span><br><span class="line">	return &#123;</span><br><span class="line">		/**</span><br><span class="line">		 * </span><br><span class="line">		 * @param &#123;Uint8Array&#125; chunk </span><br><span class="line">		 */</span><br><span class="line">		write(chunk) &#123;</span><br><span class="line">			writer.write(chunk);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;string&#125; userID </span><br><span class="line"> * @param &#123;string | null&#125; hostName</span><br><span class="line"> * @returns &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">function getVLESSConfig(userID, hostName) &#123;</span><br><span class="line">	const vlessMain = `vless://$&#123;userID&#125;@$&#123;hostName&#125;:443?encryption=none&amp;security=tls&amp;sni=$&#123;hostName&#125;&amp;fp=randomized&amp;type=ws&amp;host=$&#123;hostName&#125;&amp;path=%2F%3Fed%3D2048#$&#123;hostName&#125;`</span><br><span class="line">	return `</span><br><span class="line">################################################################</span><br><span class="line">v2ray</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">$&#123;vlessMain&#125;</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">################################################################</span><br><span class="line">clash-meta</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">- type: vless</span><br><span class="line">  name: $&#123;hostName&#125;</span><br><span class="line">  server: $&#123;hostName&#125;</span><br><span class="line">  port: 443</span><br><span class="line">  uuid: $&#123;userID&#125;</span><br><span class="line">  network: ws</span><br><span class="line">  tls: true</span><br><span class="line">  udp: false</span><br><span class="line">  sni: $&#123;hostName&#125;</span><br><span class="line">  client-fingerprint: chrome</span><br><span class="line">  ws-opts:</span><br><span class="line">    path: &quot;/?ed=2048&quot;</span><br><span class="line">    headers:</span><br><span class="line">      host: $&#123;hostName&#125;</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">################################################################</span><br><span class="line">`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://image.allcx.eu.org/file/154f082c42645fb11a59d.png"></p>
<p>打开本地v2软件，点击服务器，然后选择VLESS，点击用户ID后面的生成，把生成的id复制</p>
<p><img src="https://image.allcx.eu.org/file/d777976b0742205560abb.png"></p>
<p>这一步一定要选择VLESS</p>
<p>生成之后，回到cloudflare，把复制的id粘贴到第7行的引号中</p>
<p><img src="https://image.allcx.eu.org/file/9807750b2b327c9584e88.png"></p>
<p>必须要放入单引号中</p>
<p>然后选择以下五个域名中的一个，填入第9行中的引号中，替换代码中的ip</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cdn-all.xn--b6gac.eu.org</span><br><span class="line">cdn.xn--b6gac.eu.org</span><br><span class="line">cdn-b100.xn--b6gac.eu.org</span><br><span class="line">edgetunnel.anycast.eu.org</span><br><span class="line">cdn.anycast.eu.org</span><br></pre></td></tr></table></figure>

<p>五个选一个即可，如果后续觉着网速慢可以更换网址进行测试</p>
<p><img src="https://image.allcx.eu.org/file/04b6cd2d53cb11fedc976.png"></p>
<p>更换完成之后，点右上角的保存并部署，等待几秒之后并不会默认返回，需要等保存并部署这个按钮变灰之后，点击左上角箭头手动返回上一级</p>
<p><img src="https://image.allcx.eu.org/file/b6443c58f2ba02041fde1.png"></p>
<p>代码部署完成</p>
]]></content>
      <tags>
        <tag>cloudflare</tag>
      </tags>
  </entry>
  <entry>
    <title>统计文件中某个字符串出现的次数</title>
    <url>/2023/09/19/%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<p>一、grep+wc</p>
<p>1、单个字符串</p>
<p>grep -o targetStr filename | wc -l</p>
<p>例  grep -o 推送检索库成功 推送信息至检索库日志.txt | wc -l</p>
<p>备注：单个字符串可以不加引号</p>
<p>2、多个字符串</p>
<p>grep -o targetStr_1|targetStr_2|targetStr_3…… filename | wc -l</p>
<p>备注：必须加引号（单、双都可以）</p>
<p>如果不加引号，结果是不正确的</p>
<p>grep -o 一条数据里面有多个相同，会统计相同的次数</p>
<p>grep 一条数据里面有多个相同，会统计一次次数</p>
<p>二、awk</p>
<p>awk -v RS&#x3D;”@#$j” ‘{print gsub(&#x2F;targetStr&#x2F;,”&amp;”)}’ filename</p>
<p>1</p>
<p>awk  ‘{s+&#x3D;gsub(&#x2F;targetStr&#x2F;,”&amp;”)}END{print s}’ filename</p>
<p>1</p>
<p>小文件第一种方法最快0.003s，awk最快0.002s，一般都是比前者快</p>
<p>当文件大的时候awk优势会更加明显。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>免费使用cloudflare搭建v2之自定义域名</title>
    <url>/2023/09/26/%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8cloudflare%E6%90%AD%E5%BB%BAv2%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<blockquote>
<p>使用cloudflare中免费的Workers进行搭建，实现免费v2，速度一般，划水基本够用，前提为拥有cloudflare账号以及拥有自己域名。此篇为系列教程第三步</p>
</blockquote>
<p>自定义域名</p>
<p>cloudflare自动生成的域名再国内基本访问不到，所以需要使用自定义域名来进行访问，</p>
<p>在Workers 和 Pages中找到上一步部署好的Workers，点击Custom Domains 下的查看</p>
<p><img src="https://image.allcx.eu.org/file/a0711778365b6e8ba846e.png"></p>
<p>往下拉会有添加自定义域的选项，点击添加自定义域</p>
<p><img src="https://image.allcx.eu.org/file/21667f6bb4bc6c3581667.png"></p>
<p>然后输入自己的域名，前面加前缀，后面为自己的域名</p>
<p><img src="https://image.allcx.eu.org/file/5b4d7390e162204e87996.png"></p>
<p>上图中，suibian为前缀，随便添加，后面的 onjp.eu.org为自己的域名，该域名需要注册到cloudflare中，然后点击添加自定义域，等待cloudflare自行完成，</p>
<p><img src="https://image.allcx.eu.org/file/f7d4e5ba329239202914a.png"></p>
<p>完成之后会提示证书有效</p>
]]></content>
      <tags>
        <tag>cloudflare</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo分类页规则</title>
    <url>/2023/09/19/hexo%E5%88%86%E7%B1%BB%E9%A1%B5%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>分类页</p>
<p>前往你的 Hexo 博客的根目录</p>
<p>输入 hexo new page categories</p>
<p>你会找到 source&#x2F;categories&#x2F;index.md 这个文件</p>
<p>修改这个文件：</p>
<p>记得添加 type: “categories”</p>
<hr>
<p>title: 分类<br>date: 2018-01-05 00:00:00<br>type: “categories”</p>
<hr>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>win10软链接</title>
    <url>/2023/09/21/win10%E8%BD%AF%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mklink /J &quot;D:\finalshell\conn&quot; &quot;E:\OneDrive - hjblcx\documents\finalshell\conn&quot;</span><br></pre></td></tr></table></figure>

<p>在cmd窗口执行以上命令</p>
<p>在 D:\finalshell 文件夹下创建一个conn的文件夹,这个文件夹为E:\OneDrive - hjblcx\documents\finalshell\conn 这个文件夹的软连接</p>
<p>实现finalshell的多台电脑同步保存的连接信息,需要借助onedrive</p>
<p>删除软链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmdir D:\Desktop\temp\ckx</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>win</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo标签页规则</title>
    <url>/2023/09/19/hexo%E6%A0%87%E7%AD%BE%E9%A1%B5%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>标签页</p>
<p>前往你的 Hexo 博客的根目录</p>
<p>输入 hexo new page tags</p>
<p>你会找到 source&#x2F;tags&#x2F;index.md 这个文件</p>
<p>修改这个文件：</p>
<p>记得添加 type: “tags”</p>
<hr>
<p>title: 标签<br>date: 2018-01-05 00:00:00<br>type: “tags”<br>orderby: random</p>
<p>order:1</p>
<hr>
<p>参数	解释<br>type	【必须】页面类型，必须为 tags<br>orderby	【可选】排序方式 ：random&#x2F;name&#x2F;length<br>order	【可选】排序次序： 1, asc for ascending; -1, desc for descending</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>解压缩报错tar  Error is not recoverable  exiting now</title>
    <url>/2023/09/21/%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%8A%A5%E9%94%99tar-Error-is-not-recoverable-exiting-now/</url>
    <content><![CDATA[<p>[root@Gris-11140 FMIS2600bak]# tar -zxvf &#x2F;home&#x2F;oradata&#x2F;FMIS2600DMP.tar.gz</p>
<p>gzip: stdin: not in gzip format</p>
<p>tar: Child returned status 1</p>
<p>tar: Error is not recoverable: exiting now</p>
<p><strong>解决方法：</strong></p>
<p><strong>去掉z参数，使用 tar -xvf 解压正常</strong></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Cloudflare Workers 免费反代任意网站</title>
    <url>/2023/10/16/%E7%94%A8-Cloudflare-Workers-%E5%85%8D%E8%B4%B9%E5%8F%8D%E4%BB%A3%E4%BB%BB%E6%84%8F%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>WorkersProxy 是一个轻量级的 Javascript 应用程序，可从其他服务器作为客户端检索资源。</p>
<p>在 Cloudflare Workers 上进行部署时，您可以构建自定义的反向代理，而无需购买计算引擎和配置 Nginx 等 Web 服务器。</p>
<p>此外，由于您的应用程序将通过 Cloudflare 遍布 90 多个国家 &#x2F; 地区的全球数据中心网络进行分发，因此将优化关键性能，例如延迟和可用性。</p>
<p>通过配置地理位置和 IP 地址过滤器，您可以根据其特定规定在特定国家或地区直接暂停反向代理服务。利用移动重定向器，您可以根据用户的设备分发各种网页</p>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>导航到 Cloudflare Workers，注册或登录您的 Cloudflare 帐户，并为 worker 设置自定义子域，然后创建一个新的 Worker。</p>
<p>自定义 “index.js”，将代码粘贴到 Cloudflare 在线编辑器中以替换默认代码。</p>
<p>更改工作人员的名称，保存并部署它，并检查其性能是否满足您的需求。</p>
<h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><p>检查您的域当前是否处于 Cloudflare 的保护之下。</p>
<p>导航到您的域的仪表板，选择 “工作人员” 页面，然后单击 “添加路线”。</p>
<p>键入 [https:&#x2F;&#x2F;&lt;](https:&#x2F;&#x2F;;domain-name&gt;&#x2F;* 在 Route 选择之前创建的工人。</p>
<p>为您的自定义域添加 CNAME DNS 记录。具体而言，在 “名称” 字段中输入子域（或在根目录中为 “ @”），在 “目标” 字段中输入工作人员的二级域，然后将 “代理状态” 设置为 “代理”。</p>
<h1 id="自定义-index-js"><a href="#自定义-index-js" class="headerlink" title="自定义 index.js"></a>自定义 index.js</h1><p>显然，在主 Javascript 文件的顶部定义了一些常量。</p>
<p>要自定义自己的 WorkersProxy 服务，您应根据自己的期望进行编辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// List of domains bind to your WorkersProxy.</span><br><span class="line">const domain_list = [&#x27;https://google.error.workers.dev&#x27;]</span><br><span class="line"></span><br><span class="line">// Website you intended to retrieve for users.</span><br><span class="line">const upstream = &#x27;https://www.google.com/&#x27;</span><br><span class="line"></span><br><span class="line">// Website you intended to retrieve for users using mobile devices.</span><br><span class="line">const upstream_mobile = &#x27;https://www.google.com/&#x27;</span><br><span class="line"></span><br><span class="line">// Countries and regions where you wish to suspend your service.</span><br><span class="line">const blocked_region = [&#x27;KP&#x27;, &#x27;SY&#x27;, &#x27;PK&#x27;, &#x27;CU&#x27;]</span><br><span class="line"></span><br><span class="line">// IP addresses which you wish to block from using your service.</span><br><span class="line">const blocked_ip_address = [&#x27;0.0.0.0&#x27;, &#x27;127.0.0.1&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addEventListener(&#x27;fetch&#x27;, event =&gt; &#123;</span><br><span class="line">    event.respondWith(fetchAndApply(event.request));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">async function fetchAndApply(request) &#123;</span><br><span class="line"></span><br><span class="line">    const region = request.headers.get(&#x27;cf-ipcountry&#x27;).toUpperCase();</span><br><span class="line">    const ip_address = request.headers.get(&#x27;cf-connecting-ip&#x27;);</span><br><span class="line">    const user_agent = request.headers.get(&#x27;user-agent&#x27;);</span><br><span class="line">    const http = &quot;http://&quot;;</span><br><span class="line">    const https = &quot;https://&quot;;</span><br><span class="line">    </span><br><span class="line">    let response = null;</span><br><span class="line">    let url = request.url;</span><br><span class="line"></span><br><span class="line">    if (url.startsWith(http)) &#123;</span><br><span class="line">        url = url.replace(http, https);</span><br><span class="line">        response = Response.redirect(url);</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (await device_status(user_agent)) &#123;</span><br><span class="line">        upstream_domain = upstream</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        upstream_domain = upstream_mobile</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(let domain of domain_list) &#123;</span><br><span class="line">        url = url.replace(domain, upstream_domain)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    if (blocked_region.includes(region)) &#123;</span><br><span class="line">        response = new Response(&#x27;Access denied: WorkersProxy is not available in your region yet.&#x27;, &#123;</span><br><span class="line">            status: 403</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else if(blocked_ip_address.includes(ip_address))&#123;</span><br><span class="line">        response = new Response(&#x27;Access denied: Your IP address is blocked by WorkersProxy.&#x27;, &#123;</span><br><span class="line">            status: 403</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">        let method = request.method;</span><br><span class="line">        let request_headers = request.headers;</span><br><span class="line">        let new_request_headers = new Headers(request_headers)</span><br><span class="line">        let host_name = upstream_domain.replace(http, &#x27;&#x27;)</span><br><span class="line">        host_name = upstream_domain.replace(https, &#x27;&#x27;)</span><br><span class="line">        host_name = upstream_domain.replace(&#x27;/&#x27;, &#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">        new_request_headers.set(&#x27;Host&#x27;, host_name)</span><br><span class="line">        new_request_headers.set(&#x27;Referer&#x27;, upstream_domain)</span><br><span class="line"></span><br><span class="line">        origin_response = await fetch(url, &#123;</span><br><span class="line">            method: method,</span><br><span class="line">            headers: new_request_headers</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        let response_body = origin_response.body</span><br><span class="line">        let response_headers = origin_response.headers</span><br><span class="line">        let new_response_headers = new Headers(response_headers)</span><br><span class="line">        let status = origin_response.status</span><br><span class="line">        </span><br><span class="line">        new_response_headers.set(&#x27;access-control-allow-origin&#x27;, &#x27;*&#x27;);</span><br><span class="line">        new_response_headers.set(&#x27;access-control-allow-credentials&#x27;, true);</span><br><span class="line">        new_response_headers.delete(&#x27;content-security-policy&#x27;);</span><br><span class="line">        new_response_headers.delete(&#x27;content-security-policy-report-only&#x27;);</span><br><span class="line">        new_response_headers.delete(&#x27;clear-site-data&#x27;);</span><br><span class="line"></span><br><span class="line">        response = new Response(response_body, &#123;</span><br><span class="line">            status,</span><br><span class="line">            headers: response_headers</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function device_status (userAgentInfo) &#123;</span><br><span class="line">    var Agents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;];</span><br><span class="line">    var flag = true;</span><br><span class="line">    for (var v = 0; v &lt; Agents.length; v++) &#123;</span><br><span class="line">        if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123;</span><br><span class="line">            flag = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>domain_list：主域名，可以是自己的域名，记得做好解析</p>
<p>upstream、upstream_mobile：反代的网址，两者保持一致即可除非该网站有移动端的域名</p>
<p>blocked_region：禁止访问的地区，记得去除’CN’</p>
]]></content>
      <tags>
        <tag>cloudflare</tag>
      </tags>
  </entry>
  <entry>
    <title>砍价36计</title>
    <url>/2023/10/23/%E7%A0%8D%E4%BB%B7/</url>
    <content><![CDATA[<p><strong>砍价36计</strong></p>
<p><strong>第01计:瞒天过海</strong></p>
<p>　　不要表露对目标商品有好感，让商家不知道你的意图，无法争取主动</p>
<p><strong>第02计:围魏救赵</strong></p>
<p>告知自己钱刚刚花了很多在别的东西上，想买，但希望<a href="http://www.lawtime.cn/info/piaoju/fukuan/">付款</a>条件或售价能更优惠些;“老板，太不巧了，现在月末&#x2F;月初，我刚好没钱，这两天又买了XX，花了很多钱，你要是能优惠点就好了，要不真的买不了，我生活费都得靠自己，已经透支到下个月了”（有时候实在砍不下价可以让老板送店里的东西</p>
<p>​      第<strong>03****计:借刀杀人</strong></p>
<p>　　与其他店家的价格作比较，要求对方再降价</p>
<p>　  <strong>第04计:以逸待劳</strong></p>
<p>　　如果实在离自己心理价位比较远，那就参加团购搭乘顺风车，收获的不只价格优惠，更有利于约束产品品质;（如果没有团购 就淘宝搜 根据评价的细节图最终锁定目标商品，淘宝价本来就低但是也别忘了砍价）</p>
<p><strong>第05计:趁火打劫</strong></p>
<p>　一般的商品反季购买或者趁着打折促销价格要美丽很多（买房也是这样，一般滞销或者尾盘期也会发现保留的好房且折扣甚低）;</p>
<p><strong>第06计:声东击西</strong></p>
<p>　　找多位不同的卖家，试探最低价;（这个能做到心中有数</p>
<p>　　<strong>第07计:无中生有</strong></p>
<p>　　告知准备一次性付款，要求最优惠的价;（老板爽快点，最低多少。如果老板不够爽快就再加把火，老板我们都是爽快人，何必为这点钱墨迹，我拿你当朋友，诚信觉得你家东西好，正好我朋友都需要，我买回去就是给他们看看的，我们可能大批量购买的，你直接给我XX这个最低价，赚一群回头客，多好，就这样说定了，正好我包里就剩这么多了，老板给你钱）</p>
<p><strong>第08计:暗渡陈仓</strong></p>
<p>　　察言观色，有些发展商明言涨价，其实暗中给折扣。</p>
<p><strong>第09计:隔岸观火</strong></p>
<p>　　如果砍价过分顺利时，就要冷静地想想为什么。如销售员很爽快地答应了自己的折扣要求，要想一下他是否还有更低的底价没有透露?还是这件东西有其他问题，销售员急于脱手;（仔细检查商品是否有问题，如果自己忍受不了就立马走，如果觉得没事就把它放大，趁机再把价格拉低）</p>
<p>　　<strong>第10计:笑里藏刀</strong></p>
<p>　　与卖家或销售人员成为朋友，凭交情争取拿到该商品的最优惠的价格;（先套近乎最好说点你以前就是搞这个的，后来不搞了，争取共同话题，并适当争取对方的崇拜，如果争取不到就争取同情吧，然后再砍价，慢悠悠就像朋友唠嗑，僵局的时候就加个微信或者留个联系方式，表示你真的把他当朋友，“老板，东西虽然很喜欢，但价格太贵了，虽然买不了，但是交个朋友是很好的，感觉老板很会做生意，性格很好…”多点夸奖，让他觉得很不好意思，但是这个夸奖必须是基于你们沟通过程中表现出来的，不要盲目夸奖会惹人反感）</p>
<p><strong>第11计:李代桃僵</strong></p>
<p>　表示自己很满意，但家里人或朋友有其他的想法，如果便宜则可以解决问题;（老板，我挺喜欢的，但是我的东西一般都不是我买的，我刚才问我妈 ，她说在其他家也见过比这个优惠，但是我不想再跑回去买了，你直接给我便宜点，要不我妈又该骂我了）</p>
<p><strong>第12计:顺手牵羊</strong></p>
<p>“老板，算了，说这么久，您都不少，真的很不够意思，我也不说少什么了，你送我点小东西吧。你看你这里XX送我好了，也不值什么钱”（可以提前看上两件左右的东西，但是就这一件砍价，最后说算了，两件一起肯定会更便宜吧，让两件都是那个折扣，然后价钱加起来掐尾凑整，这样又能优惠点）</p>
<p>　　<strong>第13计:打草惊蛇</strong></p>
<p>　　告知自己有不少朋友也会跟着自己买，只有最优惠的价格才能带来更多买家;而且刚才有家好像和这家差不多，或者说网上也便宜些，要是老板不能再少点，就实在很抱歉</p>
<p>　<strong>第14计:借尸还魂</strong></p>
<p>　　要求给不送东西或者单件的价，同意后再要求送附加东西（比如买房，让开发商按毛胚房给你价，然后再让其提供装修或者提供送2年物业管理费）;</p>
<p><strong>第15计:调虎离山</strong></p>
<p>　　告知对方已看中其他家，看是否愿意开出更有吸引力的价格;（老板，刚刚看了一家也差不多，价格也和你一样，但是感觉老板你人特别好，而且我不想再跑回去了，您再价格低点，我就在你家买了）</p>
<p><strong>第16计:欲擒故纵</strong></p>
<p>告知卖家更看好其他，如果不降价就走; </p>
<p><strong>第17计:抛砖引玉</strong></p>
<p>带着钱 说只要售价合适就马上决定购买;</p>
<p><strong>第18计:擒贼擒王</strong></p>
<p>谈到一定程度销售人员就无让价余地，但只要抓住产品的实质问题和缺点，往往能寻到底价;</p>
<p>　　<strong>第19计:釜底抽薪</strong></p>
<p>　　不停地找的各种缺点，要求降价;（语气和态度要注意，千万不要惹怒卖家，否则一句话，那你别买了，你就呆了）</p>
<p><strong>第20计:混水摸鱼</strong></p>
<p>告知自己买此商品主要想用于XX，但因自己XX，借此提出是否能提供帮助，顺便送些东西</p>
<p>​       <strong>第21计:金蝉脱壳</strong></p>
<p>先选一个比较次一些的把价格谈好，再要求以同样的价格买更好的;</p>
<p><strong>第22计:关门捉贼</strong></p>
<p>　　不看样品看购买物质量毛病，逼迫其降价;（实体店就多看，多挑，淘宝直接看差评，或者看细节图  找毛病你不会呀）</p>
<p><strong>第23计:远交近攻</strong></p>
<p>　如果是网店，通过成交记录，了解过去的成交价，并与自己意欲购买的比较。如果比自己买的低就好说，如果比现在买的高，你就说他们家价格好大，趁机降价。</p>
<p><strong>第24计:假道伐虢</strong></p>
<p>告知从朋友处已知有多少优惠，要求同样的<a href="http://www.lawtime.cn/info/laodong/gongzi/">待遇</a>;或者谎称自己朋友买过好多次他们家的东西，每次都少好多，这次一定也要给自己少。</p>
<p>　    <strong>第25计:偷梁换柱</strong></p>
<p>　　抓住一件其他比目标东西价格高的东西砍价，看到一定程度夸夸老板，然后又说，没钱买那么贵的，买这个吧（锁定目标），“老板，那件那么贵，您都那么便宜，这件你就给我同样的优惠好啦，我这次没带那么多钱，下次我把那件也买了”，老板就晕了，趁着他脑子发蒙争取更优惠的付款条件;</p>
<p>　<strong>第26计:指桑骂槐</strong></p>
<p>　　列举其他家高价不让价销售不动的恶劣影响;</p>
<p><strong>第27计:假痴不癫</strong></p>
<p>多听、多看、多提问;</p>
<p><strong>第28计:上屋抽梯</strong></p>
<p>告知他你已经要买了，但要等XX才能买，因此要求卖方在付款方法上再优惠些;（比如老板 ，好了，不说那么多了，你算下多少钱，一般算出来都不是整的，你可以让抹零）或者说，老板我没带够钱，支付宝行么，或者威信支付行么。支付的时候，说老板抹个零好吧，我现在就打钱给您</p>
<p>　<strong>第29计:树上开花</strong></p>
<p>　　有经验的销售一般喜欢充分了解买家的需求，知己知彼后加以引导，这样我们往往比较被动，所以我们要尽量保持沉默，让销售多讲话、多介绍，这样可以始终处于比较有利的位置;</p>
<p><strong>第30计:反客为主</strong></p>
<p>　　比我们时间更宝贵的是卖家的时间，故意拖延时间，慢慢磨，主动权在自己手上，每次都要求更便宜的价格;（如果期间有别人要买东西，你可以帮顾客介绍，或者趁机夸下这家店。等顾客走了，老板对你的印象好，趁机再讲价）</p>
<p><strong>第31计:美人计</strong></p>
<p>　　这个看卖家是男是女，还要看自己是男是女。（主要就是说软话）</p>
<p><strong>第32计:空城计</strong></p>
<p>　　先去下厕所或者试衣间或者卖家看不到的地方，把自己的钱分散，按照自己心理价位留出这么多在钱包里，另外稍微多点零钱分散在身上或包里，其他的藏起来。老板，我就这么多钱，怎么办。老板实在不同意，你就使劲在身上找。一次摸出一点零钱，摸出一点卖下可怜，或者说，老板实在抱歉，我还是买不起，算了。基本上两次老板就受不了了，直接说好啦好啦，就这样吧。</p>
<p>　<strong>第33计:反间计</strong></p>
<p>　　告知对方已看中其他并已付定金，但亦喜欢这个，是否能再便宜点以补偿已付出不能退还的定金;</p>
<p>　　<strong>第34计:苦肉计</strong></p>
<p>　告知能力有限买不起，要求再便宜一点</p>
<p>　第35<strong>计:连环计</strong></p>
<p>　　除了自己参与砍价外，再让家人或同伴一起参与，在不同时间分别和不同的销售谈，分别前往;（我们宿舍就是，一人一台电脑或手机，旺旺轮番轰炸，使用不同的语气和计策，只要有一个最低价，其他几个就一起买）</p>
<p>　<strong>第36计:走为上</strong></p>
<p>实在谈不下去，抬腿就走。（拦你的话就有戏，不拦你的话，你心里掂量下到底喜欢么<br>再问我）</p>
<p>其实好多总结起来有异曲同工之妙，可能你看不出区别，但是当你真正砍过很多价的时候，融会贯通，其实也没有区别，因为要促成交易成功，有时候都是混着来的，不必区分那么清楚，结果是最总要的——物美价廉</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>b站无人直播</title>
    <url>/2023/10/24/b%E7%AB%99%E6%97%A0%E4%BA%BA%E7%9B%B4%E6%92%AD/</url>
    <content><![CDATA[<p>1.先弄b站推流，类似ck：<a href="https://link.bilibili.com/p/center/index#/my-room/start-live">选分类，开播。复制→服务器地址+串流密钥</a><br>2.服务器一键拉库<br>curl -fsSL get.kplayer.net | bash<br>3.配置文件<a href="https://file.uhsea.com/2310/f8be897bd2c6818137d865da5c4d7a93RS.txt">config.yaml(点击下载)</a>，文件在服务器的root\kplayer，把推流代码放进去保存就行。<br>4.然后在服务器root\新建一个文件夹Downloads存放视频文件，上传文件xxx.mp4。<br>5.上面的B站点击开启直播，出现推流码后，然后服务器cd kplayer<br>.&#x2F;kplayer play start –daemon<br>返回刷新，查看B站直播间就行了。</p>
]]></content>
      <tags>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title>免费使用cloudflare搭建v2之获取配置使用</title>
    <url>/2023/10/25/%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8cloudflare%E6%90%AD%E5%BB%BAv2%E4%B9%8B%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>使用cloudflare中免费的Workers进行搭建，实现免费v2，速度一般，划水基本够用，前提为拥有cloudflare账号以及拥有自己域名。此篇为系列教程第四步</p>
</blockquote>
<h6 id="获取节点配置"><a href="#获取节点配置" class="headerlink" title="获取节点配置"></a>获取节点配置</h6><p>参考第二步部署代码的方法，再次拿到生成的uuid，复制出来</p>
<p><img src="https://image.allcx.eu.org/file/67341bbaa78a2c667ea8d.png"></p>
<p>打开第三步中输入的自定义域名，在域名后面加一个 &#x2F; 再加刚才复制出来的uuid，在浏览器中打开，即可获得vless配置，如图</p>
<p><img src="https://image.allcx.eu.org/file/5f721a161c7bd1c3bd1c7.png"></p>
<p>导入v2软件即可使用，</p>
<p>至此搭建完成</p>
<p>速度一般，ipv6地址会一直在变化</p>
]]></content>
      <tags>
        <tag>cloudflare</tag>
      </tags>
  </entry>
</search>
